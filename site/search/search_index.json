{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Transparency \u2013 Types (Python)","text":"<p>Typed Python models for the Civic Transparency Schema Definitions (Pydantic v2).</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install civic-transparency-types\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from ci.transparency.types import Series\n\nseries = Series(\n    topic=\"#CityElection2026\",\n    generated_at=\"2026-02-07T00:00:00Z\",  # ISO 8601; parsed to datetime\n    interval=\"minute\",\n    points=[],  # add your time-bucketed data here\n)\nprint(series.model_dump())  # dict ready to JSON-serialize\n</code></pre> <p>Pydantic validation example (what happens on bad input):</p> <pre><code>from ci.transparency.types import Meta\nfrom pydantic import ValidationError\n\ntry:\n    Meta(topic=\"ok\", window={\"start\": \"2026-02-01T00:00:00Z\"})  # missing 'end'\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"#what-you-get","title":"What you get","text":"<ul> <li>Typed models: <code>Meta</code>, <code>Run</code>, <code>Scenario</code>, <code>Series</code>, <code>ProvenanceTag</code></li> <li>Validation: Pydantic v2 enforces schema constraints (formats, enums, min/max, patterns)</li> <li>Interop: <code>.model_dump()</code> for JSON, <code>.model_validate()</code> to load/validate existing data</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":"<ul> <li>Meta</li> <li>Run</li> <li>Scenario</li> <li>Series</li> <li>Provenance Tag</li> </ul>"},{"location":"#versioning","title":"Versioning","text":"<p>These types are generated from the Civic Transparency Schema Definitions. Keep your project pinned to a compatible versions set (e.g., <code>civic-transparency-types==0.1.x</code>) to avoid unexpected breaking changes.</p>"},{"location":"api/","title":"API","text":"<p>Typed models reflect the Civic Transparency schemas and are exposed via a single public package:</p> <pre><code>import ci.transparency.types as ct\nct.__all__  # -&gt; [\"Meta\", \"Run\", \"Scenario\", \"Series\", \"ProvenanceTag\"]\nct.__version__  # string, set by setuptools-scm\n</code></pre>"},{"location":"api/#package-overview","title":"Package overview","text":"<ul> <li><code>ci.transparency.spec</code>: Normative Draft-07 JSON Schemas and OpenAPI definitions.</li> <li><code>ci.transparency.types</code>: Runtime model layer using Pydantic, backed by JSON Schemas.</li> </ul>"},{"location":"api/#public-modules-classes","title":"Public modules / classes","text":"<ul> <li><code>ci.transparency.types</code> (barrel module)</li> <li><code>Meta</code></li> <li><code>Run</code></li> <li><code>Scenario</code></li> <li><code>Series</code></li> <li><code>ProvenanceTag</code></li> <li><code>__version__</code> (string)</li> </ul> <p>The concrete fields come directly from the JSON Schemas. See per-class reference: - Meta - Run - Scenario - Series - Provenance Tag</p>"},{"location":"api/#base-behavior-pydantic-v2","title":"Base behavior (Pydantic v2)","text":"<p>All models inherit from <code>pydantic.BaseModel</code> and therefore support the standard API:</p> <pre><code>m = ct.Series(...)\nm.model_dump()           # -&gt; dict (JSON-ready)\nm.model_dump_json()      # -&gt; JSON string\nm.model_copy(update={})  # shallow copy w/ updates\nm.model_json_schema()    # JSON Schema derived from the model\ntype(m).model_validate(obj)         # validate existing dict\ntype(m).model_validate_json(bytes)  # validate JSON string/bytes\n</code></pre>"},{"location":"api/#validation-strictness","title":"Validation &amp; strictness","text":"<ul> <li>Types follow the schema definitions: for example, a property with \"format\": \"date-time\" becomes a datetime field in Python.</li> <li>Unknown fields are rejected (<code>extra=\"forbid\"</code>).</li> <li>Enums / patterns / min/max from the schema definitions are enforced by Pydantic at runtime.</li> </ul> <pre><code>from pydantic import ValidationError\n\ntry:\n    ct.ProvenanceTag(acct_type=\"wizard\")  # not in enum\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"api/#serialization","title":"Serialization","text":"<ul> <li><code>.model_dump()</code> returns plain Python types (safe for <code>json.dumps</code>).</li> <li><code>.model_dump_json()</code> returns a string using Pydantic\u2019s encoder (datetimes to ISO 8601, etc.).</li> <li>Use <code>by_alias=True</code> if you later add field aliases.</li> </ul>"},{"location":"api/#json-schema-for-tool-integration","title":"JSON Schema (for tool integration)","text":"<p>If you need a Pydantic-generated JSON Schema for a specific model:</p> <pre><code>schema = ct.Series.model_json_schema()\n</code></pre> <p>Note: this Pydantic-generated schema is useful for tooling, but the normative definitions live in the <code>civic-transparency-spec</code> package (Draft-07). If you must validate against the normative definitions, see Usage / Validating with jsonschema.</p>"},{"location":"api/#accessing-the-schema-definitions","title":"Accessing the Schema Definitions","text":"<p>The normative JSON Schemas ship in the <code>civic-transparency-spec</code> package:</p> <pre><code>import json\nfrom importlib.resources import files\n\ntext = files(\"ci.transparency.spec.schemas\").joinpath(\"series.schema.json\").read_text(\"utf-8\")\nseries_schema = json.loads(text)\n</code></pre> <p>You can then validate payloads with <code>jsonschema</code> (see examples in Usage).</p>"},{"location":"api/#versioning","title":"Versioning","text":"<ul> <li>This package tracks the schema definitions closely. Pin compatible versions for reproducibility:   <code>bash   pip install \"civic-transparency-types==0.1.*\" \"civic-transparency-spec==0.1.*\"</code></li> <li><code>ci.transparency.types.__version__</code> exposes the installed package version string.</li> </ul>"},{"location":"api/#import-patterns","title":"Import patterns","text":"<p>Barrel import (recommended):</p> <pre><code>from ci.transparency.types import Series, Meta, Run, Scenario, ProvenanceTag\n</code></pre> <p>Per-module import (helpful for IDE \"go to definition\"):</p> <pre><code>from ci.transparency.types.series import Series\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>This page shows common patterns for loading, validating, and serializing Civic Transparency types.</p>"},{"location":"usage/#install","title":"Install","text":"<pre><code>pip install civic-transparency-types\n# (optional, recommended) pin alongside the schema definitions\npip install \"civic-transparency-types==0.1.*\" \"civic-transparency-spec==0.1.*\"\n</code></pre>"},{"location":"usage/#create-and-validate","title":"Create and validate","text":"<pre><code>from ci.transparency.types import Series\n\nseries = Series(\n    topic=\"#CityElection2026\",\n    generated_at=\"2026-02-07T00:00:00Z\",  # parsed to datetime\n    interval=\"minute\",\n    points=[],\n)\n</code></pre> <p>If any field violates the model (enum, pattern, required, etc.), Pydantic raises <code>ValidationError</code>.</p> <pre><code>from pydantic import ValidationError\nfrom ci.transparency.types import Meta\n\ntry:\n    Meta(  # 'window.end' missing, will fail\n        topic=\"topic\",\n        window={\"start\": \"2026-02-01T00:00:00Z\"},\n        notes=None,\n        seed=0,\n        accounts_generated=0,\n        posts_raw=0,\n        buckets_aggregated=0,\n        scenario_file=\"scenario.yaml\",\n        scenario_sha256=\"0\"*64,\n        events=[],\n    )\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/#serialize-deserialize","title":"Serialize / deserialize","text":"<p>To send/store:</p> <pre><code>payload: dict = series.model_dump()         # JSON-friendly dict\ntext: str = series.model_dump_json(indent=2)\n</code></pre> <p>To load an existing dict/JSON and validate:</p> <pre><code>from ci.transparency.types import Series\n\nloaded = Series.model_validate(payload)         # dict -&gt; Series\nloaded2 = Series.model_validate_json(text)      # JSON -&gt; Series\n</code></pre>"},{"location":"usage/#validating-with-jsonschema","title":"Validating with jsonschema","text":"<p>If you want an extra guardrail using the official Draft-07 schemas:</p> <pre><code>import json\nfrom importlib.resources import files\nfrom jsonschema import Draft7Validator\n\n# 1) get the normative schema from the spec package\nschema_text = files(\"ci.transparency.spec.schemas\").joinpath(\"series.schema.json\").read_text(\"utf-8\")\nseries_schema = json.loads(schema_text)\n\n# 2) validate the payload dict you produced with Pydantic\nDraft7Validator.check_schema(series_schema)          # sanity check the schema itself\nDraft7Validator(series_schema).validate(payload)     # raises jsonschema.ValidationError if invalid\n</code></pre>"},{"location":"usage/#round-trip-file-io","title":"Round-trip file I/O","text":"<pre><code>import json\nfrom pathlib import Path\nfrom ci.transparency.types import Series\n\nout = Path(\"series.json\")\n\n# write\nout.write_text(Series(...).model_dump_json(indent=2), encoding=\"utf-8\")\n\n# read + validate\ndata = json.loads(out.read_text(encoding=\"utf-8\"))\nseries = Series.model_validate(data)\n</code></pre>"},{"location":"usage/#using-with-fastapi-optional","title":"Using with FastAPI (optional)","text":"<p>Pydantic v2 models work out-of-the-box:</p> <pre><code>from fastapi import FastAPI\nfrom ci.transparency.types import Series\n\napp = FastAPI()\n\n@app.post(\"/series\")\ndef post_series(s: Series) -&gt; Series:\n    # s is validated already\n    return s  # echo back, or transform and return\n</code></pre>"},{"location":"usage/#generating-regenerating-the-types-contributors","title":"Generating / Regenerating the types (contributors)","text":"<p>Types are generated from the <code>civic-transparency-spec</code> package with <code>datamodel-code-generator</code>.</p> <pre><code># in the types repo\npython scripts/generate_types.py\n</code></pre> <p>CI tip (to ensure generated code is up to date):</p> <pre><code>python scripts/generate_types.py\ngit diff --exit-code\n</code></pre>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":"<p>\u201cUnknown field \u2026\u201d The models are strict (<code>extra=\"forbid\"</code>). Remove unexpected keys or update the schema definitions &amp; regenerate.</p> <p>Datetime parsing Use ISO 8601 (<code>YYYY-MM-DDTHH:MM:SSZ</code> or with offset). Pydantic converts to <code>datetime</code>.</p> <p>Version mismatches Pin both packages to compatible <code>0.1.*</code> versions. If the definitions change, regenerate types.</p>"},{"location":"usage/#see-also","title":"See also","text":"<ul> <li>Schemas: https://civic-interconnect.github.io/civic-transparency-spec/</li> <li>API Reference:</li> <li>Meta</li> <li>Run</li> <li>Scenario</li> <li>Series</li> <li>Provenance Tag</li> </ul>"},{"location":"reference/meta/","title":"Meta (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Run-level metadata describing how a Series document (and related artifacts) was produced.</p>"},{"location":"reference/provenance_tag/","title":"Provenance Tag (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Per-post provenance tags in the Civic Transparency standard. Values are bucketed/categorical\u2014no PII or direct identifiers.</p>"},{"location":"reference/run/","title":"Run (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Environment and build metadata captured at generation time (useful for provenance, debugging, and reproducibility).</p>"},{"location":"reference/scenario/","title":"Scenario (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Input scenario used to drive simulations or aggregation runs: topic, window, personas, and optional events.</p>"},{"location":"reference/series/","title":"Series (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Aggregated, privacy-preserving behavior series for a topic over time.</p>"}]}