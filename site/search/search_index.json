{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Civic Transparency \u2013 Types (Python)","text":"<p>Strongly-typed Python models for the Civic Transparency specification, built with Pydantic v2.</p>"},{"location":"#what-this-package-provides","title":"What This Package Provides","text":"<ul> <li>Runtime Type Safety: Full validation of civic transparency data structures</li> <li>IDE Support: Complete type hints and autocompletion</li> <li>Schema Compliance: Generated directly from canonical JSON schemas</li> <li>Privacy Compliance: Built-in validation for privacy-preserving data patterns</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install civic-transparency-types\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from ci.transparency.types import Series\nfrom datetime import datetime\n\n# Create a validated civic data series\nseries = Series(\n    topic=\"#CityBudget2025\",\n    generated_at=datetime.now().isoformat() + \"Z\",\n    interval=\"minute\",\n    points=[]  # Your aggregated, privacy-preserving data points\n)\n\n# Automatic validation ensures schema compliance\nvalidated_data = series.model_dump()  # Safe for JSON serialization\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#type-safety","title":"Type Safety","text":"<p>All models enforce the Civic Transparency schema constraints at runtime: - Enum validation for categorical fields - Date/time format validation (ISO 8601) - Numeric range and string pattern validation - Required field enforcement</p>"},{"location":"#privacy-by-design","title":"Privacy by Design","text":"<p>The type system enforces privacy-preserving patterns: - No direct identifiers allowed - Bucketed categorical values (e.g., account age ranges) - Aggregated statistical summaries only - Deduplication hashes instead of content</p>"},{"location":"#easy-integration","title":"Easy Integration","text":"<p>Works seamlessly with modern Python tooling: - FastAPI: Automatic request/response validation - Dataclasses: Compatible with existing data structures - JSON APIs: Native serialization/deserialization - Testing: Clear validation error messages</p>"},{"location":"#available-types","title":"Available Types","text":"Model Purpose Key Fields Series Time-bucketed aggregated data <code>topic</code>, <code>points</code>, <code>interval</code> ProvenanceTag Post metadata (no PII) <code>acct_type</code>, <code>automation_flag</code>, <code>media_provenance</code>"},{"location":"#see-also","title":"See Also","text":"<ul> <li>API Reference: Complete type documentation</li> <li>Series Reference: Detailed field documentation</li> <li>Provenance Tag Reference: Metadata field guide</li> <li>Performance Guide: Performance guide</li> <li>Usage Guide: Common patterns and examples</li> </ul>"},{"location":"#relationship-to-specification","title":"Relationship to Specification","text":"<p>This package provides the runtime implementation of types defined in the Civic Transparency specification. The types are automatically generated from the canonical JSON schemas, ensuring perfect alignment with the specification.</p> <p>For schema definitions, OpenAPI documentation, and specification details, visit the spec repository.</p>"},{"location":"api/","title":"API Reference","text":"<p>The Civic Transparency Types package provides a clean, typed interface to the Civic Transparency specification. All models are built with Pydantic v2 and automatically validate against the canonical JSON schemas.</p>"},{"location":"api/#package-overview","title":"Package Overview","text":"<pre><code>import ci.transparency.types as ct\n\n# Available models\nct.Series          # Time-bucketed civic data\nct.ProvenanceTag   # Post metadata (privacy-preserving)\n\n# Package metadata\nct.__version__     # Current package version\nct.__all__         # Public API surface\n</code></pre>"},{"location":"api/#public-api","title":"Public API","text":""},{"location":"api/#core-models","title":"Core Models","text":"Class Purpose Schema Source <code>Series</code> Aggregated time series for civic topics <code>series.schema.json</code> <code>ProvenanceTag</code> Categorical post metadata (no PII) <code>provenance_tag.schema.json</code>"},{"location":"api/#package-information","title":"Package Information","text":"<ul> <li><code>__version__</code> (str): Current package version</li> <li><code>__all__</code> (List[str]): Public API exports</li> </ul>"},{"location":"api/#import-patterns","title":"Import Patterns","text":""},{"location":"api/#recommended-barrel-import","title":"Recommended: Barrel Import","text":"<pre><code>from ci.transparency.types import Series, ProvenanceTag\n\n# Clean, simple imports for application code\nseries = Series(...)\ntag = ProvenanceTag(...)\n</code></pre>"},{"location":"api/#alternative-direct-module-import","title":"Alternative: Direct Module Import","text":"<pre><code>from ci.transparency.types.series import Series\nfrom ci.transparency.types.provenance_tag import ProvenanceTag\n\n# Useful for IDE \"go to definition\" and explicit dependencies\n</code></pre>"},{"location":"api/#package-level-import","title":"Package-Level Import","text":"<pre><code>import ci.transparency.types as ct\n\n# Namespaced access\nseries = ct.Series(...)\nversion = ct.__version__\n</code></pre>"},{"location":"api/#base-model-behavior","title":"Base Model Behavior","text":"<p>All types inherit from <code>pydantic.BaseModel</code> and provide the complete Pydantic v2 API:</p>"},{"location":"api/#instance-methods","title":"Instance Methods","text":"<pre><code>series = Series(...)\n\n# Serialization\ndata = series.model_dump()                    # \u2192 dict (JSON-safe)\njson_str = series.model_dump_json()           # \u2192 JSON string\njson_pretty = series.model_dump_json(indent=2)  # \u2192 Pretty JSON\n\n# Copying and updating\nupdated = series.model_copy(update={'topic': '#NewTopic'})\n</code></pre>"},{"location":"api/#class-methods","title":"Class Methods","text":"<pre><code># Validation and parsing\nseries = Series.model_validate(data_dict)        # dict \u2192 Series\nseries = Series.model_validate_json(json_string) # JSON \u2192 Series\n\n# Schema introspection  \nschema = Series.model_json_schema()              # Pydantic-generated schema\nfields = Series.model_fields                     # Field definitions\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":"<p>All models use strict validation: - <code>extra=\"forbid\"</code>: Unknown fields are rejected - Type coercion: Automatic type conversion where safe - Validation: Full constraint checking (patterns, ranges, enums)</p>"},{"location":"api/#validation-features","title":"Validation Features","text":""},{"location":"api/#runtime-type-safety","title":"Runtime Type Safety","text":"<pre><code>from pydantic import ValidationError\n\ntry:\n    # This will fail validation\n    invalid_series = Series(\n        topic=\"\",  # Empty string not allowed\n        generated_at=\"not-a-date\",  # Invalid datetime\n        interval=\"invalid\",  # Not in enum\n        points=[]\n    )\nexcept ValidationError as e:\n    print(f\"Validation errors: {e}\")\n</code></pre>"},{"location":"api/#enum-validation","title":"Enum Validation","text":"<pre><code>from ci.transparency.types import ProvenanceTag\n\n# Valid enum values are enforced\ntag = ProvenanceTag(\n    acct_type=\"person\",        # \u2713 Valid\n    automation_flag=\"manual\"   # \u2713 Valid\n    # acct_type=\"wizard\"       # \u2717 Would raise ValidationError\n)\n</code></pre>"},{"location":"api/#pattern-and-range-validation","title":"Pattern and Range Validation","text":"<pre><code># String patterns, numeric ranges, etc. are validated\ntag = ProvenanceTag(\n    dedup_hash=\"abc123\",       # \u2713 Valid hex pattern\n    origin_hint=\"US-CA\",       # \u2713 Valid country-region format\n    # dedup_hash=\"xyz!\"        # \u2717 Invalid characters\n)\n</code></pre>"},{"location":"api/#schema-access","title":"Schema Access","text":""},{"location":"api/#pydantic-schema-runtime","title":"Pydantic Schema (Runtime)","text":"<pre><code># Get Pydantic-generated schema for tooling\nschema = Series.model_json_schema()\nprint(schema['properties']['topic'])  # Field definition\n</code></pre>"},{"location":"api/#canonical-schema-normative","title":"Canonical Schema (Normative)","text":"<p>Access the official JSON schemas that define the specification:</p> <pre><code>import json\nfrom importlib.resources import files\n\n# Get the source-of-truth schema\nschema_text = files(\"ci.transparency.spec.schemas\").joinpath(\n    \"series.schema.json\"\n).read_text(\"utf-8\")\ncanonical_schema = json.loads(schema_text)\n\n# Use for validation, documentation generation, etc.\nfrom jsonschema import Draft202012Validator\nvalidator = Draft202012Validator(canonical_schema)\nvalidator.validate(series.model_dump())\n</code></pre>"},{"location":"api/#serialization-details","title":"Serialization Details","text":""},{"location":"api/#json-compatibility","title":"JSON Compatibility","text":"<pre><code>series = Series(...)\n\n# These produce equivalent JSON-safe data\ndata1 = series.model_dump()\ndata2 = json.loads(series.model_dump_json())\nassert data1 == data2\n</code></pre>"},{"location":"api/#datetime-handling","title":"Datetime Handling","text":"<pre><code>from datetime import datetime\n\nseries = Series(\n    generated_at=datetime.now(),  # Accepts datetime objects\n    # ...\n)\n\n# Serializes to ISO 8601 strings\ndata = series.model_dump()\nassert isinstance(data['generated_at'], str)  # \"2025-01-15T12:00:00Z\"\n</code></pre>"},{"location":"api/#field-customization","title":"Field Customization","text":"<pre><code># Exclude fields during serialization\npublic_data = series.model_dump(exclude={'generated_at'})\n\n# Include only specific fields\nminimal_data = series.model_dump(include={'topic', 'interval'})\n\n# Use aliases if defined (none currently in this spec)\naliased_data = series.model_dump(by_alias=True)\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":""},{"location":"api/#validation-errors","title":"Validation Errors","text":"<pre><code>from pydantic import ValidationError\n\ndef safe_parse_series(data: dict) -&gt; Series | None:\n    \"\"\"Parse series data with error handling.\"\"\"\n    try:\n        return Series.model_validate(data)\n    except ValidationError as e:\n        # Log specific validation failures\n        for error in e.errors():\n            field = \" \u2192 \".join(str(loc) for loc in error['loc'])\n            print(f\"Validation error in {field}: {error['msg']}\")\n        return None\n</code></pre>"},{"location":"api/#field-level-errors","title":"Field-Level Errors","text":"<pre><code>try:\n    Series.model_validate(bad_data)\nexcept ValidationError as e:\n    for error in e.errors():\n        print(f\"Field: {error['loc']}\")       # Which field failed\n        print(f\"Value: {error['input']}\")     # The invalid input\n        print(f\"Error: {error['msg']}\")       # What went wrong\n        print(f\"Type: {error['type']}\")       # Error category\n</code></pre>"},{"location":"api/#framework-integration","title":"Framework Integration","text":""},{"location":"api/#fastapi","title":"FastAPI","text":"<p>Automatic request/response validation:</p> <pre><code>from fastapi import FastAPI\nfrom ci.transparency.types import Series\n\napp = FastAPI()\n\n@app.post(\"/data\")\nasync def receive_data(series: Series) -&gt; dict:\n    # 'series' is automatically validated\n    return {\"received\": series.topic}\n</code></pre>"},{"location":"api/#dataclasses-integration","title":"Dataclasses Integration","text":"<pre><code>from dataclasses import dataclass\nfrom ci.transparency.types import Series\n\n@dataclass\nclass ProcessingResult:\n    series: Series\n    processed_at: str\n\n    def to_dict(self):\n        return {\n            'series': self.series.model_dump(),\n            'processed_at': self.processed_at\n        }\n</code></pre>"},{"location":"api/#django-models","title":"Django Models","text":"<pre><code>from django.db import models\nfrom ci.transparency.types import Series\nimport json\n\nclass CivicDataRecord(models.Model):\n    topic = models.CharField(max_length=255)\n    data = models.JSONField()\n\n    def get_series(self) -&gt; Series:\n        return Series.model_validate(self.data)\n\n    def set_series(self, series: Series):\n        self.topic = series.topic\n        self.data = series.model_dump()\n</code></pre>"},{"location":"api/#type-information","title":"Type Information","text":""},{"location":"api/#static-type-checking","title":"Static Type Checking","text":"<p>The package includes <code>py.typed</code> for full mypy/pyright support:</p> <pre><code>from ci.transparency.types import Series\n\ndef process_series(series: Series) -&gt; str:\n    # Full type safety and IDE completion\n    return series.topic.upper()\n\n# mypy will catch type errors\nprocess_series(\"not a series\")  # Error: Argument 1 has incompatible type\n</code></pre>"},{"location":"api/#runtime-type-inspection","title":"Runtime Type Inspection","text":"<pre><code>from ci.transparency.types import Series\nimport inspect\n\n# Inspect model structure\nprint(Series.__annotations__)  # Field type annotations\nprint(Series.model_fields)     # Pydantic field definitions\n\n# Check inheritance\nassert issubclass(Series, BaseModel)\n</code></pre>"},{"location":"performance/","title":"Performance Guide","text":"<p>When working with civic transparency data at scale, these performance characteristics and optimizations can help you build efficient applications.</p>"},{"location":"performance/#benchmark-results","title":"Benchmark Results","text":"<p>Performance measured on Windows Python 3.11.9 (your results may vary based on hardware and Python version):</p>"},{"location":"performance/#validation-performance","title":"Validation Performance","text":"Model Type Records/sec Time per Record Use Case ProvenanceTag ~160,000 0.006ms Post metadata validation Series (minimal) ~25,000 0.040ms Simple time series Series (100 points) ~259 3.861ms Complex time series"},{"location":"performance/#json-serialization-performance","title":"JSON Serialization Performance","text":"Model Type Pydantic JSON stdlib json Speedup ProvenanceTag ~651,000/sec ~269,000/sec 2.4x Series (minimal) ~228,000/sec ~91,000/sec 2.5x Series (100 points) ~3,531/sec ~1,511/sec 2.3x <p>Key Insight: Pydantic's <code>model_dump_json()</code> is consistently ~2.4x faster than <code>model_dump()</code> + <code>json.dumps()</code>.</p>"},{"location":"performance/#memory-usage","title":"Memory Usage","text":"Model Type Memory per Object JSON Size Efficiency ProvenanceTag ~1,084 bytes 207 bytes 5.2x overhead Series (minimal) ~7,127 bytes 502 bytes 14.2x overhead Series (100 points) ~660,159 bytes 40,796 bytes 16.2x overhead <p>Memory overhead includes Python object structures, Pydantic metadata, and validation caching.</p>"},{"location":"performance/#performance-patterns","title":"Performance Patterns","text":""},{"location":"performance/#1-complexity-scaling","title":"1. Complexity Scaling","text":"<ul> <li>ProvenanceTag: Simple enum validation is very fast</li> <li>Series: Scales linearly with number of data points</li> <li>Nested validation: Each point requires full coordinate validation</li> </ul>"},{"location":"performance/#2-serialization-vs-validation","title":"2. Serialization vs Validation","text":"<ul> <li>Serialization is faster: JSON generation is 4-25x faster than validation</li> <li>Pydantic optimized: Built-in JSON serializer beats stdlib significantly</li> <li>Memory efficient: JSON representation is much more compact</li> </ul>"},{"location":"performance/#3-privacy-preserving-design-impact","title":"3. Privacy-Preserving Design Impact","text":"<p>The privacy-by-design approach actually helps performance: - Bucketed enums (like <code>acct_age_bucket</code>) validate faster than ranges - Categorical data requires less processing than continuous values - Aggregated structures reduce individual record complexity</p>"},{"location":"performance/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"performance/#high-throughput-validation","title":"High-Throughput Validation","text":"<p>For processing large volumes of civic data:</p> <pre><code>from ci.transparency.types import ProvenanceTag\nfrom typing import List, Dict, Any\nimport logging\n\ndef process_provenance_batch(data_list: List[Dict[str, Any]]) -&gt; List[ProvenanceTag]:\n    \"\"\"Process ~160K records/second efficiently.\"\"\"\n    results = []\n    errors = 0\n\n    for data in data_list:\n        try:\n            tag = ProvenanceTag.model_validate(data)\n            results.append(tag)\n        except ValidationError as e:\n            errors += 1\n            if errors &lt; 10:  # Log first few errors\n                logging.warning(f\"Validation failed: {e}\")\n\n    return results\n\n# Expected throughput: ~160,000 ProvenanceTags/second\n</code></pre>"},{"location":"performance/#efficient-series-processing","title":"Efficient Series Processing","text":"<p>For time series data with many points:</p> <pre><code>from ci.transparency.types import Series\n\ndef process_series_stream(data_stream):\n    \"\"\"Stream processing for memory efficiency.\"\"\"\n    for series_data in data_stream:\n        # Validate once per series (~259/second for 100-point series)\n        series = Series.model_validate(series_data)\n\n        # Process and immediately serialize to save memory\n        result = series.model_dump_json()  # ~3,531/second\n        yield result\n\n        # series goes out of scope, freeing ~660KB\n</code></pre>"},{"location":"performance/#json-optimization","title":"JSON Optimization","text":"<p>Choose serialization method based on your needs:</p> <pre><code># Fastest: Use Pydantic's built-in JSON (recommended)\njson_str = series.model_dump_json()  # ~228K/sec for minimal series\n\n# Alternative: For custom JSON formatting\nimport orjson  # Install separately for even better performance\n\ndata = series.model_dump(mode='json')  # Convert enums to values\njson_bytes = orjson.dumps(data)       # Potentially faster than stdlib\n</code></pre>"},{"location":"performance/#memory-management","title":"Memory Management","text":"<p>For processing large datasets:</p> <pre><code>import gc\nfrom typing import Iterator\n\ndef memory_efficient_processing(large_dataset: Iterator[dict]):\n    \"\"\"Process data without loading everything into memory.\"\"\"\n    batch_size = 1000\n    batch = []\n\n    for record in large_dataset:\n        batch.append(record)\n\n        if len(batch) &gt;= batch_size:\n            # Process batch\n            results = [ProvenanceTag.model_validate(data) for data in batch]\n\n            # Yield results and clear memory\n            yield from results\n            batch.clear()\n\n            # Optional: Force garbage collection for long-running processes\n            if len(results) % 10000 == 0:\n                gc.collect()\n</code></pre>"},{"location":"performance/#production-considerations","title":"Production Considerations","text":""},{"location":"performance/#database-integration","title":"Database Integration","text":"<p>Based on the memory usage, consider your storage strategy:</p> <pre><code># For ProvenanceTag (1KB each): Can safely keep thousands in memory\nprovenance_cache = {}  # OK to cache frequently accessed tags\n\n# For Series (7KB-660KB each): Stream processing recommended\ndef store_series_efficiently(series: Series):\n    # Store as compressed JSON rather than keeping objects in memory\n    json_data = series.model_dump_json()\n    compressed = gzip.compress(json_data.encode())\n    database.store(compressed)\n</code></pre>"},{"location":"performance/#api-design","title":"API Design","text":"<p>Design your APIs based on these performance characteristics:</p> <pre><code>from fastapi import FastAPI\nfrom ci.transparency.types import ProvenanceTag, Series\n\napp = FastAPI()\n\n@app.post(\"/provenance/batch\")\nasync def upload_provenance_batch(tags: List[ProvenanceTag]):\n    # Can handle large batches efficiently (~160K/sec validation)\n    return {\"processed\": len(tags)}\n\n@app.post(\"/series\")\nasync def upload_series(series: Series):\n    # Individual series upload (validation cost depends on point count)\n    point_count = len(series.points)\n    if point_count &gt; 1000:\n        # Consider async processing for very large series\n        return {\"status\": \"queued\", \"points\": point_count}\n    return {\"status\": \"processed\", \"points\": point_count}\n</code></pre>"},{"location":"performance/#when-performance-matters","title":"When Performance Matters","text":""},{"location":"performance/#high-performance-scenarios","title":"High-Performance Scenarios","text":"<ul> <li>Real-time civic monitoring: ProvenanceTag validation at 160K/sec supports live analysis</li> <li>Batch processing: Can process millions of records efficiently</li> <li>API endpoints: Fast enough for responsive web applications</li> </ul>"},{"location":"performance/#optimization-not-needed","title":"Optimization Not Needed","text":"<ul> <li>Typical civic research: These speeds far exceed most analytical workloads</li> <li>Small datasets: Optimization overhead not worth it for &lt;10K records</li> <li>Prototype development: Focus on correctness first, optimize later</li> </ul>"},{"location":"performance/#monitoring-performance","title":"Monitoring Performance","text":"<p>Add performance monitoring to your applications:</p> <pre><code>import time\nimport logging\n\nclass PerformanceMonitor:\n    def __init__(self, name: str):\n        self.name = name\n        self.start_time = None\n\n    def __enter__(self):\n        self.start_time = time.perf_counter()\n        return self\n\n    def __exit__(self, *args):\n        duration = time.perf_counter() - self.start_time\n        logging.info(f\"{self.name} took {duration:.3f}s\")\n\n# Usage\nwith PerformanceMonitor(\"ProvenanceTag validation\"):\n    tags = [ProvenanceTag.model_validate(data) for data in batch]\n</code></pre>"},{"location":"performance/#summary","title":"Summary","text":"<p>The civic transparency types deliver high performance for privacy-preserving data processing:</p> <ul> <li>Production-ready speeds: 160K+ validations/second for metadata</li> <li>Efficient serialization: Built-in JSON optimization  </li> <li>Predictable scaling: Performance scales with data complexity</li> <li>Memory conscious: Reasonable overhead for rich validation</li> </ul> <p>The privacy-by-design architecture (bucketed enums, aggregated data) improves performance compared to handling raw, detailed data structures.</p>"},{"location":"usage/","title":"Usage","text":"<p>This page shows common patterns for loading, validating, and serializing Civic Transparency types.</p>"},{"location":"usage/#install","title":"Install","text":"<pre><code>pip install \"civic-transparency-types==0.2.*\" \"civic-transparency-spec==0.2.*\"\n</code></pre>"},{"location":"usage/#create-and-validate","title":"Create and validate","text":"<pre><code>from ci.transparency.types import Series\n\nseries = Series(\n    topic=\"#CityElection2026\",\n    generated_at=\"2026-02-07T00:00:00Z\",  # parsed to datetime\n    interval=\"minute\",\n    points=[],\n)\n</code></pre>"},{"location":"usage/#serialize-deserialize","title":"Serialize / deserialize","text":"<p>To send/store:</p> <pre><code>payload: dict = series.model_dump()         # JSON-friendly dict\ntext: str = series.model_dump_json(indent=2)\n</code></pre> <p>To load an existing dict/JSON and validate:</p> <pre><code>from ci.transparency.types import Series\n\nloaded = Series.model_validate(payload)         # dict -&gt; Series\nloaded2 = Series.model_validate_json(text)      # JSON -&gt; Series\n</code></pre>"},{"location":"usage/#validating-with-jsonschema","title":"Validating with jsonschema","text":"<p>If you want an extra guardrail using the official schemas:</p> <pre><code>import json\nfrom importlib.resources import files\nfrom jsonschema import Draft202012Validator\n\n# 1) get the normative schema from the spec package\nschema_text = files(\"ci.transparency.spec.schemas\").joinpath(\"series.schema.json\").read_text(\"utf-8\")\nseries_schema = json.loads(schema_text)\n\n# 2) validate the payload dict you produced with Pydantic\nDraft202012Validator.check_schema(series_schema)          # sanity check the schema itself\nDraft202012Validator(series_schema).validate(payload)     # raises jsonschema.ValidationError if invalid\n</code></pre>"},{"location":"usage/#round-trip-file-io","title":"Round-trip file I/O","text":"<pre><code>import json\nfrom pathlib import Path\nfrom ci.transparency.types import Series\n\nout = Path(\"series.json\")\n\n# write\nout.write_text(Series(...).model_dump_json(indent=2), encoding=\"utf-8\")\n\n# read + validate\ndata = json.loads(out.read_text(encoding=\"utf-8\"))\nseries = Series.model_validate(data)\n</code></pre>"},{"location":"usage/#using-with-fastapi-optional","title":"Using with FastAPI (optional)","text":"<p>Pydantic v2 models work out-of-the-box:</p> <pre><code>from fastapi import FastAPI\nfrom ci.transparency.types import Series\n\napp = FastAPI()\n\n@app.post(\"/series\")\ndef post_series(s: Series) -&gt; Series:\n    # s is validated already\n    return s  # echo back, or transform and return\n</code></pre>"},{"location":"usage/#generating-regenerating-the-types-contributors","title":"Generating / Regenerating the types (contributors)","text":"<p>Types are generated from the <code>civic-transparency-spec</code> package with <code>datamodel-code-generator</code>.</p> <pre><code># in the types repo\npython scripts/generate_types.py\n</code></pre> <p>CI tip (to ensure generated code is up to date):</p> <pre><code>python scripts/generate_types.py\ngit diff --exit-code\n</code></pre>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":"<p>\u201cUnknown field \u2026\u201d The models are strict (<code>extra=\"forbid\"</code>). Remove unexpected keys or update the schema definitions &amp; regenerate.</p> <p>Datetime parsing Use ISO 8601 (<code>YYYY-MM-DDTHH:MM:SSZ</code> or with offset). Pydantic converts to <code>datetime</code>.</p> <p>Version mismatches Pin both packages to compatible versions. If the definitions change, regenerate types.</p>"},{"location":"usage/#see-also","title":"See also","text":"<ul> <li>Schemas: https://civic-interconnect.github.io/civic-transparency-spec/</li> <li>API Reference:</li> <li>Series</li> <li>Provenance Tag</li> </ul>"},{"location":"reference/provenance_tag/","title":"Provenance Tag (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Per-post provenance tags. Values are bucketed/categorical\u2014no PII or direct identifiers.</p>"},{"location":"reference/series/","title":"Series (Pydantic)","text":"<p>               Bases: <code>BaseModel</code></p> <p>Aggregated, privacy-preserving behavior series for a topic over time.</p>"}]}